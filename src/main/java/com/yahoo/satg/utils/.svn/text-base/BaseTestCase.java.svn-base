package com.yahoo.satg.utils;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.Writer;
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

import org.apache.log4j.Logger;
import org.w3c.dom.Element;

import com.yahoo.idm.IDMAccountTypeCode;
import com.yahoo.idm.IDMAssetTypeCode;
import com.yahoo.idm.IDMId;
import com.yahoo.sm.ads.common.app.test.AbstractSpringEnabledTestCase;
import com.yahoo.sm.ads.common.test.ServiceManagerTestSupport;
import com.yahoo.sm.ads.idm.test.MockUserContext;
import com.yahoo.sm.ads.idm.test.MockUserContext.UCKey;
import com.yahoo.sm.ads.idm.LoginService;
import com.yahoo.sm.ads.idm.UserContext;
import com.yahoo.sm.ads.services.lookup.data.CallerTypeEnum;

/**
 * Base test class of common helper methods for test cases
 * 
 * @author sglaser
 */

public abstract class BaseTestCase extends AbstractSpringEnabledTestCase {

	private static final Logger log = Logger.getLogger(BaseTestCase.class);
	private static boolean oneTimeSetUp = true;
	private static LoginService loginService;
	private Throwable error;
	private static int pc;
	private static List<UserContext> ucList;
	private static boolean blockThreads = true;
	protected static TestUtil testUtil;
	protected static UserContext uc;
	protected static StringBuilder testPassDesc = new StringBuilder("Test completed successfully\n");

	public BaseTestCase(String name) {
		super(name);
	}

	protected void setUp() throws Exception {
		super.setUp();
		//testPassDesc.setLength(0);
		oneTimeSetUp();
		log.info("========== " + getName() + " ==========");
	}

    // In multi-threaded mode only one thread should invoke oneTimeSetup
	public void oneTimeSetUp() throws Exception {
		if (oneTimeSetUp) {
			oneTimeSetUp = false;
			testUtil = getTestUtil();
			testUtil.setTestEnvData();
			ServiceManagerTestSupport.setUp("targeting.persist.datasource",
					new String[] { "java:/hibernate/ExchSessionFactory",
							"java:/hibernate/IDMSessionFactory",
							"java:/hibernate/CustSessionFactory" },
					"service-manager.xml");
			loginService = getBean(LoginService.class);
            ucList = loadAccounts(System.getProperty("acctfile"));
            blockThreads = false;
		}
		
        // All other threads wait for thread running oneTimeSetUp to finish
		while (blockThreads) {
        	Thread.sleep(250);
        }
	}

	public static TestUtil getTestUtil() throws Exception {
		return getTestUtil(false);
	}

	public static TestUtil getTestUtil(boolean setTestEnv) throws Exception {
		if (testUtil == null)
			testUtil = new TestUtil();
		if (setTestEnv == true)
			testUtil.setTestEnvData();
		return testUtil;
	}

	public LoginService getLoginService() {
		if (loginService == null)
			loginService = getBean(LoginService.class);
		return loginService;
	}

	/*
	 * Perform these operations after each test case, such a updating TM
	 */
	protected void tearDown() throws Exception {
		super.tearDown();
		String testType = System.getProperty("testType");
		String updateTM = System.getProperty("updateTM", "true");
		TestId testCaseId = getClass().getMethod(super.getName())
				.getAnnotation(TestId.class);

//		String description="";
//		if(sb.length()==0)
//		{
//			sb.append("Test with the test case id "+testCaseId + " passed" );
//			description= sb.toString();
//		}
//		else
//			description= sb.toString();
		
		
		if (testCaseId == null) {
			log.warn(getName() + " was not associated with a TM test case id");
		} else {
			log.info(getName() + " (" + testCaseId.value() + ") " + " passed? "
					+ wasSuccessful());
			if (!Boolean.parseBoolean(updateTM)) {
				log.info("Updating TM disabled by system property updateTM");
			} else if (!testType.equals("perf")) {
				testUtil.updateTestManager(testCaseId.value(),
						(wasSuccessful() == true ? "Pass" : "Fail"),
						cleanupString(wasSuccessful() == true ? "Test Passed" 
								: error.getLocalizedMessage()),
						cleanupString(wasSuccessful() == true ? testPassDesc.toString()
								: getStackTrace(error)));
			}
		}
	}

	protected void runTest() throws Throwable {
		try {
			super.runTest();
		} catch (Throwable t) {
			error = t;
			throw t;
		}
	}

	/**
	 * Clean up the strings before sending to TM as the TM API is very fragile
	 * 
	 * @param input
	 */
	private String cleanupString(String input) {
		if (input == null || input.length() == 0) {
			return "";
		}
		StringBuilder sb = new StringBuilder(input);
		int length = sb.length();
		for (int i = 0; i < length; i++) {
			char ch = sb.charAt(i);
			if (ch == '$') {
				sb.setCharAt(i, '%');
			} else if (ch == '[' || ch == ']') {
				sb.setCharAt(i, ' ');
			}
		}
		return sb.toString();
	}

	/*
	 * Get stack trace as a string
	 */
	private static String getStackTrace(Throwable aThrowable) {
		final Writer result = new StringWriter();
		final PrintWriter printWriter = new PrintWriter(result);
		aThrowable.printStackTrace(printWriter);
		return result.toString();
	}

	/*
	 * Create a mock user context object
	 */
	public static UserContext getMockUserContext() {

		try {
			Map<UCKey, Object> props = new HashMap<UCKey, Object>();
			// props.put(UCKey.ACCOUNT_ASP_ID, seatHolderId);
			// props.put(UCKey.USERCOMPANY_LONGID, companyId);
			props.put(UCKey.USERNAME, testUtil.getUserName());
			uc = new MockUserContext(props, null, null, null)
					.createMockUserContext(testUtil.getMasterAccountId(),
							testUtil.getAccountId());
		} catch (Exception e) {
			e.printStackTrace();
			fail();
		}
		return uc;
	}

	/*
	 * Get a real user context object
	 */
	
	public static UserContext getUserContext() {

		 long longysmAccountId = testUtil.getMasterAccountId();
		 long longspendAccountId = testUtil.getAccountId();
		 String username = testUtil.getUserName();
		 String password = testUtil.getPassword();

		if (uc != null
	    && username.equals(uc.getUserName())
	    && longysmAccountId == uc.getMasterAccountId()
	    && longspendAccountId == uc.getAccountId())
		    return uc;

		 return getUserContext(longysmAccountId, longspendAccountId, username, password);
	}
	
	public static UserContext getUserContext(long longysmAccountId, long longspendAccountId, String username, String password) {

        IDMId ysmAccountId = IDMId.longAccountId(
				IDMAccountTypeCode.ACCOUNTTYPE_YSMACCOUNT, longysmAccountId);
		log.info("### ysmAccountId " + ysmAccountId.toString());

		try {
			uc = loginService.createUserContext(CallerTypeEnum.UI, username,
					password, ysmAccountId, null);
			log.info("### UserContext: " + uc.toString());
			uc.switchYsmAccount(ysmAccountId);
			if (longspendAccountId != 0) {
				IDMId spendAccountId = IDMId.longAssetId(
						IDMAssetTypeCode.ASSETTYPE_DEMAND, longspendAccountId);
				log.info("### spendAccountId " + spendAccountId.toString());
				uc.switchSpendAccount(spendAccountId);
			}
		} catch (Exception e) {
			log.error("Error trying to create a UserContext: "
					+ e.getLocalizedMessage());
			e.printStackTrace();
		}
		return uc;
	}
	
	// Provide a factory of UCs, each unique
	public static synchronized UserContext getPerfUserContext() {

		if (getThreadData("uc") != null) {
			return (UserContext) getThreadData("uc");
		}
		
        if (ucList == null || ucList.isEmpty()) {
            log.error("ERROR: UC list created by loadAccounts is empty");
            return null;
        }

		UserContext uc = ucList.get(pc);
		pc++;

		setThreadData("uc", uc);
		return uc;
	}
	
	/*
	 * Provide data structures to store data local to each thread. For example
	 * each thread could have it's own user context object
	 */
	private static ThreadLocal<HashMap> threadLocalData = new ThreadLocal<HashMap>() {
		protected HashMap initialValue() {
			return new HashMap();
		}
	};

	public static Object getThreadData(Object key) {
		return threadLocalData.get().get(key);
	}

	public static void setThreadData(Object key, Object value) {
		threadLocalData.get().put(key, value);
	}

	public static List<UserContext> loadAccounts(String acctFilename) throws Exception {

        // Only load accounts if perf
        if (!System.getProperty("testType").equals("perf")) return null;

        // Check if accounts file exists
        if (acctFilename == null) {
			log.warn("No account file passed, skipping loadAccounts()");
            return null;
		}
        
		File acctFile = new File(acctFilename);
		if (!acctFile.exists()) {
			throw new Exception("Unable to load file " + acctFilename
					+ ", does not exist.");
		}

		FileReader fr = new FileReader(acctFile);
		BufferedReader br = new BufferedReader(fr);
		String line = null;

		// Skip the header line
		if ((line = br.readLine()) == null) {
			throw new Exception("File " + acctFilename
					+ " does not have a header");
		}
	     
		List<UserContext> ucList = new ArrayList<UserContext>();
		
		while ((line = br.readLine()) != null) {
			String[] acct = line.split(",");

			// Check there are only 4 columns per line
			if (acct.length != 4) {
				throw new Exception("File " + acctFilename
						+ " is missing some columns");
			}
			
			// Create user context and add to list
            log.info("########## Line = " + acct[0] + " " + acct[1] + " " + acct[2] + " " + acct[3]);
			UserContext uc = getUserContext(Long.parseLong(acct[0]), Long.parseLong(acct[1]), acct[2], acct[3]);
			ucList.add(uc);
		}

		br.close();
		fr.close();

        // Check # of UCs > # of users
        Element config = testUtil.getTestElementByName("PerfTest", "execute");
        config = testUtil.getTestElementByName(config.getParentNode().getNodeName(), config.getAttribute("config"));
        int users = Integer.parseInt(config.getAttribute("users"));
        if (users > ucList.size()) {
            throw new Exception("Only created " + ucList.size() + " UCs for " + users + " users");
        }

		return ucList;
	}

	/*
	 * Get cause of inner most nested exception. Example usage:
	 * getInnermostException(e).getClass().isInstance(new
	 * IllegalArgumentException()))
	 */
	public Throwable getInnermostException(Throwable ex) {
		Throwable currentCause = ex.getCause();
		if (currentCause == null) {
			return null;
		} else {
			Throwable innerCause = getInnermostException(currentCause);
			if (innerCause == null) {
				return currentCause;
			} else {
				return innerCause;
			}
		}
	}
}
